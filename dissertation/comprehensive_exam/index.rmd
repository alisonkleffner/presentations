---
title: "A Spatio-Temporal Model of Arctic Sea Ice"
subtitle: "Comprehensive Exam"
author: "Alison Kleffner"
date: "Department of Statistics, University of Nebraska - Lincoln"
output:
  xaringan::moon_reader:
    seal: true
    includes:
      after_body:
        "js-addins.html"
    #mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: ["default", "metropolis-fonts", "metropolis" ,"css/modal.css", "css/sizeformat.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightlines: true
      countIncrementalSlides: true
---
class:primary

```{r, child = "style.Rmd"}
```


```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# Packages
library(emoji)
library(purrr)
library(tidyverse)
library(gridExtra)
library(nullabor)
library(scales)
library(knitr)
library(kableExtra)
library(RefManageR)
library(iconr)
library(fontawesome)
library(shiny)
# download_fontawesome()

# References
bib <- ReadBib("bib/thesis.bib", check = FALSE)
ui <- "- "

# R markdown options
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE,
                      dpi = 300)
options(htmltools.dir.version = FALSE)
options(knitr.kable.NA = '')
```

```{r, include = F, eval = T, cache = T}
clean_file_name <- function(x) {
  basename(x) %>% str_remove("\\..*?$") %>% str_remove_all("[^[A-z0-9_]]")
}
img_modal <- function(src, alt = "", id = clean_file_name(src), other = "") {
  
  other_arg <- paste0("'", as.character(other), "'") %>%
    paste(names(other), ., sep = "=") %>%
    paste(collapse = " ")
  
  js <- glue::glue("<script>
        /* Get the modal*/
          var modal{id} = document.getElementById('modal{id}');
        /* Get the image and insert it inside the modal - use its 'alt' text as a caption*/
          var img{id} = document.getElementById('img{id}');
          var modalImg{id} = document.getElementById('imgmodal{id}');
          var captionText{id} = document.getElementById('caption{id}');
          img{id}.onclick = function(){{
            modal{id}.style.display = 'block';
            modalImg{id}.src = this.src;
            captionText{id}.innerHTML = this.alt;
          }}
          /* When the user clicks on the modalImg, close it*/
          modalImg{id}.onclick = function() {{
            modal{id}.style.display = 'none';
          }}
</script>")
  
  html <- glue::glue(
     " <!-- Trigger the Modal -->
<img id='img{id}' src='{src}' alt='{alt}' {other_arg}>
<!-- The Modal -->
<div id='modal{id}' class='modal'>
  <!-- Modal Content (The Image) -->
  <img class='modal-content' id='imgmodal{id}'>
  <!-- Modal Caption (Image Text) -->
  <div id='caption{id}' class='modal-caption'></div>
</div>
"
  )
  write(js, file = "js-addins.html", append = T)
  return(html)
}
# Clean the file out at the start of the compilation
write("", file = "js-addins.html")
```

# Outline


`r fa_i("arrows")` Motivation and Background

`r fa_i("list")` Research Objectives

`r fa_i("info")` Spatio-Temporal Clustering: Bounding Box

`r fa_i("info")` Spatio-Temporal Interpolation: Intersection Model

`r fa_i("ruler")` Simulation Study

`r fa_i("ruler")` Results with Ice Data

`r fa_i("check-double")` Discussion and Conclusion

`r fa_i("spinner")` Future Work


---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Motivation and Background
]

---
class:primary

# Importance of Arctic Sea Ice Crack Detection

+ Sea ice is a barrier between the atmosphere and the ocean
+ Cracks, or leads, may form in the ice pack due to dynamic processes
  - Allows for heat from the ocean to be transferred to the atmosphere `r Citep(bib[[c("schreyer_elastic_2006")]])`. 
  - Accounts for half of the heat flux between the ocean and atmosphere `r Citep(bib[[c("badgley_1961")]])`
+ Previous ice crack detection methods can generally be split into two categories: thermal and deformation. 
  

.center[
```{r ice-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/Ice Chunk.png", alt = " Artice Sea Ice with Crack", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary

# Data

.center[
```{r grid-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/rgps_grid.jpg", alt = "Example of initial grid used to track movement", other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

+ Sea Ice is tracked by NASA's RADARSTAT Geophysical Processor System (RGPS), which uses synthetic aperture radar (SAR) images to track the trajectory of points on an ice sheet.
+ Each grid cell vertex is assigned an identifier (gpid) which is used for tracking
+ Set of all trajectories: 

.center[
$\mathcal{T} = (g_1, ..., g_n)$ $\\$
where $g_{n} = <s_{1,j},...,s_{t,j}>$ and $s_{i,j} = (x_{i,j}, y_{i,j})$ $\\$
$n = 1,..., 8811$ and $j = 1,2$
]



---
class:primary

# Thermal Ice Crack Detection Methods

+ Surface temperature differs between a crack and the surrounding sea ice.
+ Use thermal channels of the Advanced Very High Resolution Radiometer (AVHRR) `r Citep(bib[[c("key_detectability_1993")]])` 
  - Heavily dependent on clear skies
+ Methods have been proposed to reduce the impact of clouds 
  - Moderate Resolution Imagery Spectroradiometer (MODIS)  `r Citep(bib[[c("willmes_pan-arctic_2015")]])`
  - Fuzzy Cloud Artifact (FCAF) `r Citep(bib[[c("willmes_pan-arctic_2015")]])`
  - Passive Microwave Data  `r Citep(bib[[c("rohrs_algorithm_2012")]])`
.center[
```{r thermal-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/thermal_example.png", alt = " Output from a Thermal Algorithm (Rohrs et al, 2012)", other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]


---
class:primary

# Calculating Sea Ice Deformation

+ Deformation of a cell is determined by the motion of points `r Citep(bib[[c("peterson_evaluating_2011")]])`
    - Finds the determinant of deformation gradient to measure accumulated area changes to show persistent diverged regions. 
    - Can find the size and orientation of the crack
+ Drawbacks
  - Not as high of resolution as thermal methods
  - The error in the deformation product may be strongly underestimated `r Citep(bib[[c("bouillon_producing_2015")]])`

.center[
```{r deformation-pics,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/grid_example.png", alt = "Example of how find deformation (Peterson & Sulsky, 2011)", other=list(width="40%"))
i2 <- img_modal(src = "images/kinematic_crack_algorithm.png", alt = "Example of detected leads using a kinematic crack algorithm which uses the determinant of the deformation gradient to detect leads (Peterson & Sulsky, 2011)", other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```

]

---
class:primary

# Motivating Picture

.center[
```{r traj-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/traj_plot.png", alt = "Plot of gpid trajectories to show movement and directiction of movement", other=list(width="100%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]


---
class:primary

# Research Objectives

1. Develop a ice crack detection method based solely on the movement of the ice sheet
  - Cluster trajectories based on movement, where the boundaries would be possible locations of ice cracks
2. Develop a spatio-interpolation method to predict missing points along a trajectory 
  - Using the information gained from the clustering
  - Take into account nonstationarity of the data

---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Spatio-temporal Clustering: Bounding Box
]

---
class:primary

# Other Spatio-Temporal Clustering Methods

---
class:primary

# Bounding Box

+ To represent it's movement, a bounding box is created around each of the trajectories.
+ Feautures:
  - Length travel in x/y between the minimum and maximum location 
  ( $x_{max} - x_{min}$ and $y_{max} - y_{min}$)
  - Length travel in x/y between latest and earliest observation ( $x_{1} - x_{0}$ and $y_{1} - y_{0}$)
  - Angle of movement
  - Average x/y value
  - Sub-tracteroires - previous time information

.center[
```{r bb-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/bounding-box.png", alt = "Points used to Develop Bounding Box", other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]


---
class:primary

#Clustering with K-Means

- Bounding Box features were used as input into K-Means clustering, which partitions n observations into k clusters.
- Drawback: Clusters must be specified prior to clustering
  + Number of Clusters determined using the Silhouette statistic

---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Spatio-temporal Interpolation: Model in Intersections
]

---
class:primary

#Other Trajectory Interpolation Methods

+ Data collection method may fail, leaving positions in a trajectory unknown or may want to overcome sampling sparseness
+ Popular methods for trajectory interpolation generally are put into four categories: linear, curve, kinematic, and random walk.
+ Linear interpolation 
  - Popular due to easy in implementation
  - Performs best for linearly moving objects, or can potentially move well if sample in high frequency `r Citep(bib[[c("guo_improved_2021")]])`

.center[
```{r lin-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/lin-pic2.png", alt = "How Linear Interpolation Calculates a Missing Point", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]


---
class:primary

#Finding Spatio-Temporal Neighbors

+ Using information gained from clusters to identify spatio-temporal neighbors
  - If know how other points in the cluster move at a time point, would expect the missing point to move similarly
+ Cluster By Week
  - Intersection of one week's clusters with the week before and week after would create groups
  - Each member of a group is then a spatio-temporal neighbor of the other members as they are in a similar geographic region over time. 
  
---
class:primary

#Finding Spatio-Temporal Neighbors - Steps

1. Create a polygon around each cluster for a week - boundary coordinates of clusters
  - Done in a sequential manner
2. After a polygon is created, all gpids located in that polygon are removed.
3. Find the intersection of the polygons for the weeks. All of the points within that intersection are then spatio-temporal neighbors.

.center[
```{r int-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/intersection_ex.jpeg", alt = "Example of finding Intersection Polygons", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary

#Univariate Interpolation

+ Individual model developed for both x and y using the GpGp package in R `r Citep(bib[[c("gpgp_pkg")]])`
  - Uses the Vecchia's Approximation for a Gaussian Process
+ Vecchia's Approximation `r Citep(bib[[c("vecchia1988estimation")]])`
  - Writes the joint density as a product of conditional distributions, where only a subset of the data is used to create the conditional distributions.
  - Subset is formed by the neighbors of the observations
  - Neighbors are obtained by an ordering the points
- Used exponential space-time covariance function
- Output is the maximum likelihood estimates for the mean and covariance parameters

---
class:primary

#Univariate Interpolation

+ Predictions for x or y are made by finding the conditional expectation of the model developed.
+ Create a grid encompassing our ice sheet to give an initial estimation of the missing locations.     - The model will then adjust this location using it's known neighbors
+ Grid cell size is 10km by 10km, which allows for a max of four gpids to be located in a cell
  - The centroid of the gpids were used to estimate each grid cell
  - The size of the grid cell can impact the results


.center[
```{r ice-grid-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/ice-grid-ex.jpeg", alt = "Grid of Estimated Locations", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Simulation Study
]

---
class:primary
#Simulating Data

+ Create Underlying Process Grid  $$U_{d,c}(s,t) \sim GP(\mu_{d,c}, C_{d,c}(\theta))$$
  - Initial grid is created and shifted seven times to represent movement.
  - This data is then used in the exponential space-time covariance function.
  - Covariance parameters and defined mean trend is different for each cluster $\\$
+ Create Observed Grid
  - Movement of an observed point is determined by the value fo the nearest point of the underlying process for that day
  - Process is continued until t=7 to obtain a week's worth of simulated data
  $$(x_{t,j}, y_{t,j}) = (U^{X}_{t-1,c,g}, U^{Y}_{t-1,c,g}) + (x_{t-1,j}, y_{t-1,j})$$

.center[
```{r grid-combo-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/grid_combo.png", alt = "Underlying and Observed Grid Plotted Together", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary
#Simulating Data

Created 3 different simulated datasets, each with different parameter values.

.center[
```{r sim-traj-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/sim_traj.png", alt = "Simulated Trajectories for Each Simulation", other=list(width="90%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary

#Simulated Clustering Results

<br>
<br>
<br>

.center[
```{r sim-clust,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/sim_init_clust.png", alt = "Clusters for each Simulation at t=0", other=list(width="40%"))
i2 <- img_modal(src = "images/sim_last_clust.png", alt = "Clusters for each Simulation at t=7", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```

]


---
class:primary

#Simulated Interpolation Results

+ Simulated and clustered another week of data.
+ 10% of the data for the first week are randomly assigned to be missing.
+ Compared our method to two others:
  - Linear Interpolation
  - Instead of running model inside each intersection, a model was developed using all known points (essentially ignoring the nonstationarity aspect of our data)
  
```{r sim-results-tab1}

result_data <- data.frame(sim = c(1,2,3), X1 = c(1.496, 1.628, 1.342), Y1 = c(1.517, 1.58, 1.338), X2 = c(1.042, 1.455, 0.95), Y2 = c(1.226, 1.54, 0.92), X3 = c(1.438, 1.474, 1.458), Y3 = c(1.295, 1.488, 1.489))
 
kableExtra::kable(result_data, booktabs = TRUE, caption = "RMSE for Interpolation Methods", col.names = c("Simulation", "X", "Y", "X", "Y", "X", "Y"), escape = FALSE) %>% 
  add_header_above(c("", "Intersection" = 2, "Linear" = 2, "No Intersection" = 2))


```

---
class:primary

#Simulated Interpolation Results


```{r sim-results-tab2, message=FALSE, warning = FALSE}

result_data2 <- data.frame(sim = c(1, "", 2, "", 3, ""), Cluster = c(1,2,1,2,1,2), X1 = c(1.383, 1.573, 1.7, 1.584, 1.318,1.353), Y1 = c(1.555, 1.488, 1.653, 1.534, 1.346, 1.334), X2 = c(0.815, 1.188, 1.316, 1.503, 1.156, 0.647), Y2 = c(1.163, 1.272, 1.329, 1.612, 1.096, 0.673), X3 = c(1.562, 1.337, 1.658, 1.407, 1.434, 1.484), Y3 = c(1.29, 1.298, 1.596, 1.451, 1.405, 1.581))

kableExtra::kable(result_data2, booktabs = TRUE, caption = "RMSE for Interpolation Methods by cluster", col.names = c("Simulation", "Cluster", "X", "Y", "X", "Y", "X", "Y"), escape = FALSE, align = "c") %>% add_header_above(c(" " = 2, "Intersection" = 2, "Linear" = 2, "No Intersection" = 2)) %>% row_spec(4, color = 'black', background = 'yellow') 

```


---
class:primary

#Simulated Interpolation Results

+ A benefit of using a model-based approach is that are able to determine the uncertainty of the estimate. 
+ 30 simulations of predictions are done and used to calculate the standard deviation

```{r sim-results-tab3, message=FALSE, warning = FALSE}

result_data3 <- data.frame(sim = c(1, 2, 3), x = c(0.158, 0.094, 0.167), y = c(0.14, 0.125, 0.25))

kableExtra::kable(result_data3, booktabs = TRUE, caption = "Proportion of Intervals Contained Observed Value", col.names = c("Simulation", "x", "Y"), escape = FALSE, align = "c") 

```


---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Ice Data Results
]


---
class:primary

#Ice Data Results: Clustering Using All Data



.center[
```{r clust-all,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/all_clust.jpeg", alt = "Clustering of Ice Trajectories using All Data in Bounding Box", other=list(width="90%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary

#Clustering Using All Data - Comparison

+  Can compare our results with deformation data found using a kinematic crack algorithm calculated using the RGPS data `r Citep(bib[[c("peterson_evaluating_2011")]])`
  - Note that this image does not represent the true ice cracks, just the cracks determined by this method.

.center[
```{r all-comp-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/all-weeks-comp.png", alt = "Comparison of Our Results to a Kinematic Crack Algorithm", other=list(width="80%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]



---
class:primary

#Ice Data Results: Clustering by Week

.center[
```{r clust-week,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/clust_by_week.png", alt = "Results of Clustering by Week", other=list(width="90%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()


```

]


---
class:primary

#Ice Data Results: Clustering by Week

+ Image from a Day in the Data set of recurring leads based on visible infrared Advanaced Very High Resolution Radiometer (AVHRR) data `r Citep(bib[[c("lead_pic_2009")]])`

.center[
```{r clust-week-comp,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/week_comp.png", alt = "Comparison of a Weeks Clustering Result to AVHRR", other=list(width="60%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()


```

]

---
class:primary

#Overall Interpolation Results along Border

+ Took a random hold-out of points along the border, as the border may be locations of irregular movement
  
```{r ice-results-tab1}

result_data4 <- data.frame(Week = c(1,2,3), X1 = c(3.215, 3.539, 3.031), Y1 = c(3.408, 3.256, 2.958), X2 = c(1.606, 2.034, 0.991), Y2 = c(4.494, 1.832, 1.24))
 
kableExtra::kable(result_data4, booktabs = TRUE, caption = "RMSE for Interpolation Methods along Border", col.names = c("Week", "X", "Y", "X", "Y"), escape = FALSE) %>% 
  add_header_above(c("", "Intersection" = 2, "Linear" = 2)) %>% row_spec(1, color = 'black', background = 'yellow') 


```

---
class:primary

#Interpolation Results along Border for Week 2

```{r ice-results-tab2, message=FALSE, warning = FALSE}

result_data5 <- data.frame(Cluster = c(1,2,3,4,5), X1 = c(2.81, 2.94, 2.94, 3.26, 4.14), Y1 = c(3.04, 2.96, 3.07, 3.2, 3.88), X2 = c(3.82, 2.39, 1.46, 1.32, 0.43), Y2 = c(5.19, 0.99,1.97, 0.54, 0.34))

kableExtra::kable(result_data5, booktabs = TRUE, caption = "RMSE for Interpolation Methods by cluster for Week 2", col.names = c( "Cluster", "X", "Y", "X", "Y"), escape = FALSE, align = "c") %>% add_header_above(c(" ", "Intersection" = 2, "Linear" = 2)) %>% row_spec(1, color = 'black', background = 'yellow') 

```

---
class:primary

#Interpolation Results along Border by Week

+ Cluster 1: Data is More Spread out and not linear
+ Cluster 5: Data does not move much

.center[
```{r clust-help,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/w1_c1_traj.jpeg", alt = "Cluster Trajectories where our method performs the best", other=list(width="40%"))
i2 <- img_modal(src = "images/w2_c5_traj.jpeg", alt = "CCluster Trajectories where Linear Interpolation performs the best", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```

]

---
class:primary

#Coverage Proportion by Cluster

```{r ice-results-tab3, message=FALSE, warning = FALSE}

result_data6 <- data.frame(Cluster = c(1,2,3,4,5), X1 = c(0.467, 0.28, 0.337, 0.26, 0.149), Y1 = c(0.413, 0.278, 0.351, 0.251, 0.163))

kableExtra::kable(result_data6, booktabs = TRUE, caption = "Proportion of Prediction Interval Containing Observed Value by cluster for Week 2", col.names = c( "Cluster", "X", "Y"), escape = FALSE, align = "c") %>% row_spec(1, color = 'black', background = 'yellow') 

```



---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Discussion and Conclusion
]

---
class:primary

# Clustering with Bounding Box

+ Advantages
  - Provides information about how the data is moving
  - Shown through simulations and the ice data to provide a reasonable estimation of the locations of cracks
+ Drawbacks
  - Relies on a pre-defined number of clusters, which generally is not known
  - Have a set number of cluster, so a limit on how many cluster boundaries, thus cracks, that can be identified.
  
---
class:primary

#Intersection Model Interpolation

+ Advantages
  - Takes into account the nonstationarity of the data
  - Showed some improvement, in terms of RMSE, over linear interpolation for curved data that is not highly sampled
  - Able to estimate data on first and last day of a dataset, which linear interpolation is not able to do. 
  - Able to calculate uncertainty
  
---
class:primary

#Issues with model development

+ Log-likelihood does not converge 
  - Temporal range value is exceptionally large especially in comparison to the spatial range
+ Impractical Covariance Parameter estimates - large temporal range
  - This may be due to only working with small amount of data that is not moving much over time
  - With the simulated data, as more days were added to the dataset, the temporal range does slowly decrease
+ Potentially not a ton of data in the intersection
  - Some intersections are small
  - Need variation in time
  
  
---
class:primary

# Future Work

+ Visualization and comparison of spatial field data
+ Explaining Machine Learning Output for Spatial Data
  - To explain what the optimal management decisions are for profitability for a farmer's field, accounting for a range of factors. 
  - Develop a user-interface which will be designed around explaining machine learning output to non-experts, 
  - Build trust in the model predictions without requiring farmers to learn the details of statistical modeling.



---
class:primary
# References
<font size="2">
```{r, print_refs1, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("schreyer_elastic_2006", "badgley_1961", "key_detectability_1993", "willmes_pan-arctic_2015", "guo_improved_2021", "gpgp_pkg", "peterson_evaluating_2011", "lead_pic_2009", "vecchia1988estimation", "bouillon_producing_2015", "rohrs_algorithm_2012")]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:inverse
<br>
<br>
<br>
.center[
# Questions?
<br>
<br>

]
