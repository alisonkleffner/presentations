---
title: "Visualization and Modeling of Multivariate Data in Environmental Applications"
subtitle: "PhD Final Examination"
author: "Alison Kleffner"
date: "Department of Statistics, University of Nebraska - Lincoln"
output:
  xaringan::moon_reader:
    seal: true
    includes:
      after_body:
        "js-addins.html"
    #mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: ["default", "metropolis-fonts", "metropolis" ,"css/modal.css", "css/sizeformat.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightlines: true
      countIncrementalSlides: true
---
class:primary

```{r, child = "style.Rmd"}
```


```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# Packages
library(emoji)
library(purrr)
library(tidyverse)
library(gridExtra)
library(nullabor)
library(scales)
library(knitr)
library(kableExtra)
library(RefManageR)
library(iconr)
library(fontawesome)
library(shiny)

# download_fontawesome()

# References
bib <- ReadBib("bib/thesis.bib")
ui <- "- "

# R markdown options
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE,
                      dpi = 300)
options(htmltools.dir.version = FALSE)
options(knitr.kable.NA = '')
```

```{r, include = F, eval = T, cache = T}
clean_file_name <- function(x) {
  basename(x) %>% str_remove("\\..*?$") %>% str_remove_all("[^[A-z0-9_]]")
}
img_modal <- function(src, alt = "", id = clean_file_name(src), other = "") {
  
  other_arg <- paste0("'", as.character(other), "'") %>%
    paste(names(other), ., sep = "=") %>%
    paste(collapse = " ")
  
  js <- glue::glue("<script>
        /* Get the modal*/
          var modal{id} = document.getElementById('modal{id}');
        /* Get the image and insert it inside the modal - use its 'alt' text as a caption*/
          var img{id} = document.getElementById('img{id}');
          var modalImg{id} = document.getElementById('imgmodal{id}');
          var captionText{id} = document.getElementById('caption{id}');
          img{id}.onclick = function(){{
            modal{id}.style.display = 'block';
            modalImg{id}.src = this.src;
            captionText{id}.innerHTML = this.alt;
          }}
          /* When the user clicks on the modalImg, close it*/
          modalImg{id}.onclick = function() {{
            modal{id}.style.display = 'none';
          }}
</script>")
  
  html <- glue::glue(
     " <!-- Trigger the Modal -->
<img id='img{id}' src='{src}' alt='{alt}' {other_arg}>
<!-- The Modal -->
<div id='modal{id}' class='modal'>
  <!-- Modal Content (The Image) -->
  <img class='modal-content' id='imgmodal{id}'>
  <!-- Modal Caption (Image Text) -->
  <div id='caption{id}' class='modal-caption'></div>
</div>
"
  )
  write(js, file = "js-addins.html", append = T)
  return(html)
}
# Clean the file out at the start of the compilation
write("", file = "js-addins.html")
```

# Outline


`r fa_i("arrows")` Overall Motivation

`r fa_i("list")` Redesinging Yield Map Plots for Comprehension and Usability

`r fa_i("info")` Visual Diagnostics for Trajectory Data

`r fa_i("spinner")` Spatio-Temporal Model for Arctic Sea Ice

`r fa_i("check-double")` References

---
class:primary
# Overall Motivation


The rapid development of technology, like global position systems (GPS) and geographic information systems (GIS), has led to a dramatic increase in the amount of spatial and spatio-temporal data collected `r Citep(bib[[c("ansari_spatiotemporal_2020")]])` 

+ This growth has necessitated the development of new techniques to work with this data `r Citep(bib[[c("yuan_review_2017")]])`
+ We focus on environmental applications with multivariate spatial data and trajectory data.

---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Multivariate Spatial Data: Redesinging Yield Map Plots for Comprehension and Usability
]


---
class:primary
# Spatial Data

Spatial data relates to a geographical area or location.
+ Patterns in spatial data follow Tobler’s first law of geography, meaning everything is
related but near things are more related than distant things `r Citep(bib[[c("klippel-tobler-2011")]])` 
+ Often, more than one attribute is measured at a location. 

**Focus:** However, due to the variables occupying the same space, multivariate spatial data is complex, making it especially difficult to visualize due to issues like clutter `r Citep(bib[[c("he-mult-2019")]])`

**Example:** Visualization of crop input application versus crop yield

---
class:primary
#Background

+ With a projected increase in future crop demand, researchers are conducting studies on crop input application to increase yield, focusing on sustainability `r Citep(bib[[c("tilman_sustainalbe_2011")]])` 
+ Crop Input Example: Nitrogen Fertilizer
  - Nitrogen is an essential component of food production as allows plants to photosynthesize efficiently `r Citep(bib[[c("MAHESWARI2017175")]])`  
  - Nearly half of the nitrogen fertilizer supplied to the field is not used by the crops `r Citep(bib[[c("billen_nitrogen_2013")]])` 
  - This excess nitrogen can be harmful
+ Hence, research needs to be conducted on determining input rates that increase crop yield, and are also more sustainable.

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/tractor.png", alt = "Tractor",other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]


---
class:primary
# Data Intensive Farm Management (DIFM)

**Problem**: Address inefficient application of crop inputs to farm fields worldwide

**Methods**: On-Farm Precision Experimentation
- Conduct experiments using site-specific inputs 
- GPS-reliant technology 

**Goals**
- Develop infrastructure to develop and analyze these experiments
- Find economically optimal application rate to increase profit while reducing environmental impacts. 

[Project Website](http://difm-cig.org/)

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/logo.png", alt = "Data Intensive Farma Management (DIFM) Project",other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]

???

A common issue with farming practices across the world is the inefficient application of crop inputs, like nitrogen, on farm fields. This inefficient application of crop input impacts profit and the environment. For example nitrogen fertilizer input that is not used by crops can pollute water bodies by causing the overstimulation of growth of aquatic plants and algae, impacting light. Thus, research needs to be conducted to study this issue so steps can be taken to address it. The purpose of the data intensive farm management project, a grant funded by the USDA-NRCS, is to generate the data necessary to understand this effect of crop input application on yield, so a more optimal level can be chosen. The data is generated through the use of On-Farm precision experimentation (OFPE). In an OFPE experiments are conducted on a field using field specific inputs where the experiment is implemented using a tractor that has GPS-reliant technology. DIFM wants to develop infrastructure (including the development of apps) to easily develop and analyze these experiments, with the end goal of finding economically optimal application rate to increase profits while reducing environmental impacts.  

---
class:primary
# Trial Design and Data Collection

.pull-left[
**Step 1**: Develop infrastructure to develop experiments using site-specific inputs

[Trial Design Tool](http://trialdesign.difm-cig.org/)

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}

i2 <- img_modal(src = "images/Trial_Design.png", alt = "Example of A Trial Design", other=list(width="75%"))

c(str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

**Output**: shape files that can be put into a farmer's tractor that allows them to carry out the experiments

].pull-right[

**Step 2**: Conduct experiments and collect data

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/data_collection.png", alt = "How Data is collected",other=list(width="45%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

Examples of Data Collected:
- As-applied
- Yield
- Location of measurements

]

---
class:primary
# Explain the Results

**Step 3**: Explain the optimal management decisions, accounting for various factors


**How**: create a user interface, designed around explaining machine learning output to non-experts
  - Build trust in models
  - Learn how crop yield responds to different input application rates, field characteristics, and weather to hopefully increase profits. 
  
  
**One way to do this**: Visually explore the relationship between input application and yield through a graph
  - Show the spatial correlations between the application/treatment and yield in a way that is understandable to farmers and consultants. 
  - Develop perceptually optimal plots that communication this relationship. 
  
???

The last general step in this process is to analyze the data and explain the optimal decision management decisions, accounting for various factors (like weather, environmental and economics conditions). So we want to develop an user interface that is designed around explaining the machine learning output to non-experts to help inform decision. We want to do this to build farmer's trust in the models (we are providing them with useful information). Additionally, as a whole this will help us learn how crop yield responds to different input application rates, field characteristics, and weather with the goal to help increase profits. Currently we are working on the pieces to help explain these results, before putting it all together in an R Shiny app. One of these pieces of information that needs to be explained is to explore the relationship between input application and yield. As seen in previous parts of this presentation, there is a great benefit of plotting data, so we wanted to explore this relationship visually. Hence, we want to show the spatial correlations between the treatment application and yield in a way that is understandable to farmers and consultants. Additionally, we need to develop these plots so they are perceptually optimal.  

---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Current Maps 
]

---
class:primary
#Yield Maps Currently Used by DIFM

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/old_map.png", alt = "Example 1", other=list(width="30%"))
i2 <- img_modal(src = "images/juxtaposed-ex.jpeg", alt = "Example 2", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```


Examples of two versions of this plot currently given to farmers/crop consultants in DIFM reports

]

???

Currently, here is two examples of the plots that are currently given in DIFM reports to farmers. 

Ask the audience what principles of good graphics these violate?

---
class:primary
# Other Maps in  the Literature

.center[
Plenty of other iterations of trial design/yield maps used in the literature. Here's some examples
]


.pull-left[
.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/maxwell.png", alt = "Maxwell et al (2018)", other=list(width="80%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]


].pull-right[

.center[

```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/trevisan.png", alt = "Trevisan et al (2021)", other=list(width="80%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]

]

???

Plenty of other yield maps that have been used in the literature, so while don't give trial plot information still provides yield information over space. These have some of the same problems as seen before. The first interpolates, so losing the site-specific information and continuous yield may not make sense. The second, has too many categories and coloring is not great (rainbow). The last plot uses suboptimal color scheme (bivariate color scheme in inappropriate, also doesn't go through white, members of the target audience (farmers) may be more likely to be colorblind, so avoid reds and greens)

---
class:primary
#Juxtaposed vs Superimposed Graphs

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/jux-vs-sup.png", alt = "Juxtaposed vs Superimposed Comparative Graphs (Gleicher, Albers, Walker, et al., 2011)",other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

+ **Juxtaposed graphs**: side by side `r Citep(bib[[c("gleicher2011")]])`
  - Benefits: less issues with visual clutter and easier to create
  - Drawbacks: comparative burden is placed on the user
  

+ **Superimposed graphs**: multiple objects in same coordinate system `r Citep(bib[[c("gleicher2011")]])`
  - Benefits: Easier to compare as users can use perception rather than memory
  - Drawbacks: clutter
  - Useful when spatial location is a key component of the comparison `r Citep(bib[[c("wang_comp18")]])`
  


---
class:primary
#Data Clutter with Superimposed Graphs

**Drawback**: clutter
+ General principle of graphical design: show data clearly `r Citep(bib[[c("cleveland_graphical_1984", "gordon_2015")]])`
+ Overlap - multiple dots on top of one another
  - Obscures true number of dots, harder to find patterns
  - Visual cues, like color, becomes partially obstructed, thereby reducing search efficiency `r Citep(bib[[c("BRAVO2004b", "BRAVO2004a")]])`
  - Can overburden human perception, causing errors in performing tasks `r Citep(bib[[c("huang2009")]])`
  
.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/old_map.png", alt = "Example 1", other=list(width="20%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

???

One of the first things we need to decided is whether we want to juxtapose or superimpose the trial design and yield information. Juxtaposed graphs are side by side plots that tend to have less issues with visual clutter and they are easier to create. A drawback however, is that the comparative burden is placed on the user (have to match things up correctly). The other option is to superimpose the graphs where multiple objects are in the same coordinate system. The benefit is that it is easier to compare as users can use perception rather than memory. These are additionally useful when spatial location is a key component of the comparison. However, the major drawback, as we saw with the DIFM plot is that clutter is a major issue. We decided to use superimposed graphs since spatial location is a key component for us and may be hard to compare in two different plot (hard to match up)

---
class:primary
#Comparative Burden with Juxtaposed Graphs

**Drawback**: Most of the comparative burden placed on users' memory
+ A mental image is relied on for comparison in these scenarios, as the user moves their
eyes between images (shifting focus). 
  - The plot contents may not be accurately formed in working memory, leading to potential errors when deriving patterns  `r Citep(bib[[c("vanderplas2020", "lyi2021")]])`
+ Lack of visual cues for locations


.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/juxtaposed-ex.jpeg", alt = "Juxtaposed Example", other=list(width="35%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]

---
class:primary
#Color

+ Red-green color blindness is experienced by approximately 8% of men and 0.5% of women of
Northern European ancestry. 
  - Difficult to discriminate between these colors `r Citep(bib[[c("wong2011color")]])` 
  

+ Stop-Light Color Scheme
  - Yellow has a highlighting effect
  - Univariate Scale more appropriate (magnitude only)
  

+ Same Color scheme for multiple variables
  - May cause confusion
  

+ Rainbow Color Scheme 
  - No inherent ordering of magnitude `r Citep(bib[[c("light-rainbow-2004")]])` 
  - Extremes are visually close (red and violet) `r Citep(bib[[c("SILVA2011320")]])` 

---
class:primary
#Number of Categories

Number of categorical scales should be limited to **5-7 categories** `r Citep(bib[[c("Miller1956TheMN")]])`
.pull-left[
- Due to working memory limits `r Citep(bib[[c("macdonald_1999")]])`
  + Harder for the user to distinguish between colors and remember the meaning of colors. 
- The load on the user’s working memory leads to an increase in the time it takes for the user to comprehend the plot `r Citep(bib[[c("huang2009")]])`
].pull-right[  
  
.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/categories.png", alt = "Example 1", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]  

]

**Next:** Redesign Process

???

Additionally, the number of categories on our scale for yield should be limited to 5-7 categories (DIFM plot and other plot 2 violates this). The categories need to be limited due to working memory limits and it makes it harder for the user to distinguish between colors and remember the meaning of what group the color is representing (might associate a color with the incorrect category). This load on the user's working memory lead to an increase in time for them to comprehend the plot, which is not something we want especially for non-experts. 

Next I am going to walk through our redesign process (still currently in progress).


---
class:inverse
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Redesign
]

---
class:primary
#Redesign: Color Blending

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/Attempt1_2.png", alt = "First Iteration", other=list(width="35%"))
i2 <- img_modal(src = "images/attempt2.png", alt = "Second Iteration", other=list(width="25%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

**Focus**: Superimpose the treatment and yield plots, while reducing the clutter 
+ Use of transparency to show both at same time
+ Interactive plot with *leaflet* `r Citep(bib[[c("leaflet")]])`
  - Can add and remove trial plot layer


+ Working on blending using transparency
+ Categorical Groups for both variables
  - Trial Design treatment is a factor
  - Reduce number of colors for yield
  - Use quantiles to determine categories for yield `r Citep(bib[[c("brewer_2002")]])`


???

My first iteration of the plot I was working on superimposing both the treatment and yield plot, but reducing some of the clutter. The yield points were transformed into polygons using the distance between points, swath width, and heading (green space around plot). This was done so each polygon is on it's own unique space and not overlapping. Used transparency for the trial plot to try and blend the colors with the trial design plot. Here is used an interactive plot using the leaflet package in R, which creates interactive web maps with JavaScript. This can be beneficial as can add/remove the trial plot so can only see the yield results if desirable.

So the plot now is not cluttered in the sense there's overlapping data points, but there's still work that needs to be done. For example, the coloring needs more work. Due to colorblind, red and green may not be good colors to use, they are just the default for those working on this project. Additionally, color blending still needs to be worked on to help differentiate high treatment/high yield, etc. Finally, the shading piece may not be as effective for paper plots, which some farmers may want to use. So eventually need to think how to do this with no color.  

---
class:primary
#Redesign: Bivariate Color Plot

**Alternative to color blending**

.center[

.pull-left[

```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/color-map4.png", alt = "Bivariate Color Map", other=list(width="100%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]].pull-right[

+ **Benefit**: relationship between the variables is most important `r Citep(bib[[c("elmer2013symbol")]])` 
+ Recommendation: 3x3 scale `r Citep(bib[[c("Leonowicz2003RESEARCHOT")]])`  
  - + Quantiles `r Citep(bib[[c("biesecker-2020")]])`   
+ **Focus**: diagonal
  - Diagonal: grayscale color scheme. 
  - Upper left and lower right: complementary color scheme `r Citep(bib[[c("strode-2020")]])`
+ **Drawback**: Lose more detailed information


]



---
class:primary
#Redesign: Correlation

.center[

**Directly encode correlations between As Applied treatments and Yield**

]

.pull-left[
**Benefit**: Direct statement of correlation while maintaining some spatial orientation 
  - Explicit Encoding Layout `r Citep(bib[[c("gleicher2011")]])`
+ Bivariate color scale
+ Maintain some spatial information. 
  - Correlations may be impacted by field location
  
**Drawback**: complicated to connect the displayed relationship back to the data `r Citep(bib[[c("gleicher2011")]])`

].pull-right[

```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/corr-plot.png", alt = "Correlation")

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]


???

Finally we can directly state the correlation between As Applied and Yield (explain how as applied differs from treatment design), while also keeping some of the spatial relationship. Can see for the most part, as application amount increase, so does the yield. Some areas where the inverse is true (more investigation, maybe lower, dirt differs, etc). Used a bivariate color scheme go through white color for zero. Maintaining some spatial information is importanct as correlation is impacted by field location. Eventually this information can be added to the plot (interactivity)

---
class:primary
# Redesign: Correlation with Scatterplot

**Add some context back**

.center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/corr-with-scat2.png", alt = "Hybrid Layout", other=list(width="40%"))
i2 <- img_modal(src = "images/corr-with-scat3.png", alt = "Hybrid Layout with Hover", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i2, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9],
  str_split(i2, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]

+ A standard practice to overcome weakness of decontextualization is utilizing a hybrid comparative layout `r Citep(bib[[c("lyi2021")]])`
  - Juxtaposed scatterplot to the correlation plot
(combining the layouts of juxtaposition and explicit encoding). 
+ Interactivity connects the juxtaposed plots, where hovering over a trial plot in the correlation map highlights the corresponding points in the scatterplot used in the correlation calculation.

[Link](https://alisonkleffner.github.io/yield-map-redesign/interactive-example.html)

---
class:primary
#Conclusion/Future Work

**Next Step**: Obtain Feedback from those using the plots (farmers, crop consultants)
- Eventually do some testing between the layouts to see which farmers are reading more accurately.


**Eventually**: Develop a R Shiny app to explaining machine learning output to non-experts
- Build trust in the model predictions without requiring farmers to learn the details of statistical modeling.
- Will utilize these plots, among others
  + For example, accuracy of as applied treatment compared to trial design


---
class:inverse

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Trajectories: Visual Diagnostics for Trajectory Data
]

---
class:primary
# What are Trajectories?


+ Trajectories are considered the most complex form of data based on
points, but is also becoming more easily available `r Citep(bib[[c("kisilevich_spatio-temporal_nodate", "rinzivillo_visuallydriven_2008")]])`
  - Difficult to visualize effectively
  - Diverse set of properties
  - Different lengths
  
  .center[
```{r results='asis', echo = F, include = T, cache = T, eval = TRUE}
i1 <- img_modal(src = "images/trajectory.png", alt = "Example of a Trajectory from Ansari et
al. (2020)", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```
]



---
class:inverse

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Trajectory Visual Diagnostics
]

---
class:primary
# Background

Of common interest when studying trajectories is to discover patterns within the movements to help understand the trajectories behavior`r  Citep(bib[[c("andrienko_visual_2007")]])` 

**Visualization during Exploratory Data Analysis**: the researcher can effectively gain insight into the data in a short amount of time `r Citep(bib[[c("climate-viz")]])` 
  + Trajectories are difficult to visualize (messy)
  + But, they can still provide some insight into the underlying dynamics driving movement.

**Extract Features**: Trajectories are complicated to work with, so it may be beneficial to extract features from the raw data that can summarize its movement `r Citep(bib[[c("climate-viz")]])` 
  + Can use visualization to motivate feature creation
  + Example: `r Citep(bib[[c("wu-fish-2022")]])` developed a process called TPoSTE, which created features based on the visualization of events to separate a boat’s trajectory into periods of fishing or sailing. 
  + Want to create features that provide a quantitative summary of the movement seen in plots.

**Case Study**: Arctic Sea Ice trajectories


---
class:primary
# Data

.center[
```{r grid-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/rgps_grid.jpg", alt = "Example of initial grid used to track movement (Peterson & Sulsky, 2011)", other=list(width="25%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

+ Sea Ice can be tracked by NASA's RADARSTAT Geophysical Processor System (RGPS), which uses synthetic aperture radar (SAR) images to track the trajectory of points on an ice sheet.
+ Each grid cell vertex is assigned an identifier (cell $j=1,...,n$) which is used for tracking
+ Set of all trajectories: 

.center[
$\mathcal{G} = \left\{g_1, ..., g_n\right\}$ $\\$
where $g_{j} = \left\{s_{jt} : t \in \mathcal{T}_j\right\}$, $\mathcal{T}_j \subset \left\{t=1...T\right\}$ a collection of time points where $cell_j$ is observed $\\$
and ${s_{jt}}$ = $(x_{jt}, y_{jt})$
]

+ For our study region, $n$ = 8811, and $T$ = 22

???

An illustration of RGPS data is
shown in Fig. 7.1, where satellite views of a 50 km by 50 km region of Arctic ice
have a 5 km × 5 km RGPS grid superimposed. The time span between the first
and second observation is 18.5 h and the satellite images were recorded in mid May
2002. 

---
class:primary
# Data Difficulty

.center[
```{r traj-ex,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/traj-example.png", alt = "Example of a single trajectory in our data set", other=list(width="90%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary
# Gestalt Principles of Visual Perception

To help identify patterns, even in messy graphics, we can use the gestalt principles of visual perception to process large amounts of data efficiently. 
+ Help explain how humans naturally perceive objects and organize them in groups `r Citep(bib[[c("wagemans-2012-a", "wagemans-2012-b")]])`

.pull-left[
Principle of Similarity: people group items that look similar .
  + Trajectories with similar shapes and orientations `r Citep(bib[[c("chalbi_gestalt")]])`
.center[  
```{r law-sim,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/law-sim.png", alt = "Example of gestalt law of similarity", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]
].pull-right[
Principle of Common Fate: people tend to group objects that share a dynamic behavior, as
they might be affected by the same underlying processes `r Citep(bib[[c("chalbi_gestalt", "alais-gestalt-1998")]])` 
.center[
```{r law-fate,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/common-fate.png", alt = "Example of gestalt law of common fate", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]]


---
class:primary

# Static Trajectory Plot


+ Directed line segments, with the direction of each trajectory denoted by an arrow at the end `r Citep(bib[[c("andrienko_supporting_2000")]])` 
  - Shows the displacement and direction of each trajectory over time.
+ This plot violates several guidelines for effective visualization, making it
unsuitable for presentation.
  - However, using the principle of similarity helps a viewer easily group trajectories that look to move with a similar form in the same direction over time

.center[
```{r traj-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/traj_plot.png", alt = "Plot of id trajectories to show movement and directiction of movement", other=list(width="55%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary
# Animated Trajectory Plot

[Link](https://alisonkleffner.github.io/yield-map-redesign/traj.html)

+ Griffin, MacEachren, Hardisty, Steiner, and Li (2006) found that animated plots allowed a user to identify moving clusters easier than multiple windows of static plots. 
+ Our animation shows the incremental progress of each trajectory over time by plotting the new
location at each time step and connecting the new observation with the previous through a line segment. 
+ New information:
  - see a trajectory speeding up or slowing down through the length of the added line segments. 
  - Associate a movement with a particular day
+ Using Gestalt principle of common fate we can see that trajectories moving with a similar velocity occurs in contiguous patches.

---
class:primary

# Deriving Numerical Features: Bounding Box

+ We create a bounding box around for each trajectory to represent it's movement
+ Bounding Box Features:
  - Length travel in x/y between the minimum and maximum location 
.center[
( $x_{max} - x_{min}$ and $y_{max} - y_{min}$)]
  - Length travel in x/y between latest and earliest observation 
  .center[
  ( $x_{1} - x_{0}$ and $y_{1} - y_{0}$)]
  - Angle of movement (direction)

.center[
.pull-left[
```{r bb-pic1,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/bb_1.png", alt = "Points used to Develop Bounding Box 1", other=list(width="75%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
].pull-right[

```{r bb-pic2,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/bb_2.png", alt = "Points used to Develop Bounding Box 2", other=list(width="55%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]
]


---
class:primary
# Deriving Numerical Features: Wiggle

.center[
```{r wiggle,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/wiggle.png", alt = "Wiggle Calculation", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

+ Each trajectory consists of multiple known points connected with line segments. 
+ To determine the amount of “wiggle”, we decided to estimate the total length of the line segment (arc length).
  - The longer trajectories have moved farther over the time frame. 
+ We can estimate the total length by first finding the distance between each set of two connected
points (yellow lines).
  - We then added all the calculated distances to estimate the total length of the trajectory.



---
class:primary
# Feature Selection

+ Not all characteristics of a trajectory are simultaneously relevant when
analyzing trajectories `r Citep(bib[[c("rinzivillo_visuallydriven_2008")]])`
+ Clustering algorithm to assign trajectories to groups of similar
movements 
+ No label information to help evaluate feature importance, used visualization to make judgements `r Citep(bib[[c("li-features")]])`.
  - Redundant:  adding it to the clustering algorithm, while
holding the other variables constant, does not change the assigned clusters.
  - Relevance: help with cluster continuity

.center[
```{r feat-comp,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/feature-comparison4.png", alt = "Subsets of Clusters to Determine Relevant Features", other=list(width="60%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary
# Conclusion/Future Work

+ We can use messy plots to motivate the creation of numerical features to summarize trajectory movements.
+ The relevant features can be used to find groups of similar trajectories, and in future analyses as well.
+ In the future, we plan to extend our bounding box features to three dimensions through a case study of seabird flight trajectories.

---
class:inverse

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
.center[
# Trajectory: A Spatio-Temporal Model for Arctic Sea Ice
]

---
class:primary

# Importance of Lead Detection

+ Sea ice acts as an insulator between the warm ocean and colder atmosphere `r Citep(bib[[c("peterson_evaluating_2011")]])`
+ Cracks, or leads, may form in the ice pack due to dynamic processes
  - Allows for heat from the ocean to be transferred to the atmosphere `r Citep(bib[[c("schreyer_elastic_2006")]])`. 
  - Accounts for half of the heat flux between the ocean and atmosphere `r Citep(bib[[c("badgley_1961")]])`
+ The state of sea ice, including lead characteristics, and understanding the dynamics driving these changes provides valuable information for weather prediction, climate models, and ocean models `r Citep(bib[[c("reiser_new_2020")]])` 
+ Previous ice crack detection methods can generally be split into two categories: thermal and deformation. 
  

.center[
```{r ice-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/Ice Chunk.png", alt = " Artice Sea Ice with Crack", other=list(width="35%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

---
class:primary

# Other Lead Detection Methods

.pull-left[
**Thermal**
+ Surface temperature differs between a lead and the surrounding sea ice.
+ Use thermal channels of the Advanced Very High Resolution Radiometer (AVHRR) `r Citep(bib[[c("key_detectability_1993")]])` 
  - Heavily dependent on clear skies and has issues with thin ice
+ Methods have been proposed to reduce the impact of clouds 
.center[
```{r thermal-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/thermal_example.png", alt = " Output from a Thermal Algorithm (Rohrs et al, 2012)", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]
].pull-right[
**Deformation**
+ Cell deformation is determined by point motion `r Citep(bib[[c("peterson_evaluating_2011")]])`
    - The determinant of the deformation gradient measures accumulated area changes
    - Can find the size and orientation
+ Drawbacks
  - Need complete set of space-time observations to calculate deformation
  - Underestimation of error in deformation product

.center[
```{r deformation-pics,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/kinematic_crack_algorithm.png", alt = "Example of detected leads using a kinematic crack algorithm which uses the determinant of the deformation gradient to detect leads (Peterson & Sulsky, 2011)", other=list(width="30%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```

]
]

---
class:primary

# Research Objectives

1. Develop a Lead detection method
  - Address some drawbacks of the other methods by using only the movement of the sea ice
  - Cluster trajectories based on movement  
  - The boundaries would be possible locations of leads, as the underlying process causes the sea ice to move differently depending on the location
2. By applying information gained from clustering, we developed a spatio-temporal model to reconstruct the underlying process, which can be used to estimate missing points along a trajectory.
  - Take into account nonstationarity of the data (estimate parameters separately for each cluster)


---
class:primary
# Review of Methods

**Lead Detection**: used bounding box features in K-Means clustering, which partitions $n$ observations into $k$ clusters
+ Drawback: Number of Clusters must be specified prior to clustering
  - Number of Clusters determined by Silhouette statistic `r Citep(bib[[c("kodinariya_2013")]])`
+ Found through simulations and the sea ice trajectories that our method provides a reasonable estimation of lead locations  

**Model Development**: Using information gained from clusters to identify spatio-temporal neighbors
+ Would expect a missing point at that time to move similarly to known points in same cluster
+ Cluster trajectories by week to find neighbors
  - Cluster by weeks because it is the smallest interval could detect movement and also see some continuity between weeks
  - Intersection of one week's clusters with the week before and week after would create groups
  - Each member of a group is then a spatio-temporal neighbor of the other members as they are in a similar geographic region over time. 
  
---
class:primary

#Missing Data

+ In general, data collection methods may fail, leaving positions in a trajectory unknown or may want to overcome sampling sparseness
+ In our case, missing data is due to the path of the satellite used to collect the data. 

.center[
```{r missing-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/data_example.jpeg", alt = "Missing Data within the Ice Sheet", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]



---
class:primary

#INLA

We developed a model to reconstruct the underlying process (assumed Gaussian), where we simultaneously obtain the movement in $x$ (called $u$) and the movement in $y$ (called $v$) at time $t$.
+ The movements are added to the previous location to estimate the missing location
$$(\hat{u}_t, \hat{v}_t) + (x_{t-1}, y_{t-1}) = (x_t, y_t)$$


We elected to use the Integrated Nested Laplace Approximation (INLA) approach
  + Computational benefits over other methods, as it focuses on models that can be expressed as latent Gaussian Markov Random Fields (GMRF)
  + Easily accounts for the spatio-temporal structure of the data during the inferential process `r Citep(bib[[c("spde-book")]])`


---
class:primary

#INLA: Continuously Indexed GF

Bivariate Data can be defined by the joint process: $$\left\{H(s,t), (s,t) \in \mathcal{D} \in \mathcal{R}\right\}$$ where there are $N$ spatial locations at $t$ time points.

The process is assumed Gaussian, where the model can be rewritten as 
$$H_{k_{i,t}} \sim BivN(\eta_{i,t}, \sigma^2_e)$$ 
with $\sigma^2_e$ representing the nugget effect and the linear predictor is defined as 

$$\eta_{i,t} = \alpha + w_{i,t}$$ 
with $\alpha$ denoting the intercept and the realization of the latent ST Gaussian Field (GF) is represented by $w \sim GF(0,\Sigma)$. The covariance function $(\Sigma)$ is the separable Matern ST covariance function `r Citep(bib[[c("BLANGIARDO201333")]])`. 

---
class:primary

#INLA: SPDE

When working with point data (like our trajectories), assuming a continuously indexed GF for $w_{i,t}$ is not a computationally efficient approach.

Instead used stochastic partial differential equations (SPDE)- represent a GF with Matern Covariance Function through a discretely indexed process called a GMRF `r Citep(bib[[c("spde-book")]])`
.pull-left[
- Discrete Index is created with a constrained delaunay triangulation
.center[
```{r spde,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/mesh-ex.png", alt = "Example of the triangulation of a field used in our simulation study", other=list(width="90%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]].pull-right[
  
The linear predictor can then be rewritten as 
$$\eta_{i,t} = \alpha + \sum^{G}_{g=1}\tilde{A}\tilde{w}$$ 
where $\tilde{A}$ is a sparse precision matrix mapping the GMRF, $\tilde{w}$, from $N$ locations to the $G$ nodes in the triangulation
]

---
class:primary
#Final Model

Specifically for our model to jointly measure the underlying process, the linear predictor is written as
$$\eta_{it} = \alpha_u + \alpha_{v} + z_{u}(s,t) + z_{v}(s,t) + z_{uv}(s,t)$$

where $\alpha_u$ + $\alpha_{v}$ are the intercepts for each response and the $z$ functions represent the SPDE model for the $u$ and $v$ spatio-temporal effects, along with their interaction.

We developed a model within each intersection to account for the non-stationary aspect of our data using only the data at time t, only data from t − 1, t, and t + 1. 

**Using Model**: Create a spatial grid encompassing the sea ice. 
  + The centroid of the grid cells become a starting estimation of the missing $g_j$. 
  + The underlying process should be smooth within an intersection, so the centroid should have a similar value of the underlying process. 
  + Once we create the grid for initial location estimates of the missing data, we used the developed bivariate model to find the predicted locations.

---
class:primary
#Overview of Results from Simulation Study

Compared four different methods:
  + Linear Interpolation
  + Joint Nonstationary Spatio-Temporal Model
  + Joint Nonstationary Spatial Model with time fixed effect
  + Joint Stationary Spatio-Temporal Model
  
Results:
  + Joint Stationary Spatio-Temporal Model generally performs the worst
  + The spatial model with fixed time (for y) and the spatio-temporal model (for x) perform better than linear interpolation for less smooth underlying processes

---
class:primary

#Overall Interpolation Results

+ Took a random hold-out of points along the border, as the border may be locations of irregular movement
  
```{r ice-results-tab1}

result_data4 <- data.frame(Week = c(1,2,3), X1 = c(1.100, 1.340, 0.366), Y1 = c(2.610, 1.767, 0.396), X2 = c(2.154, 3.146, 1.693), Y2 = c(5.530, 2.061, 1.031))
 
kableExtra::kable(result_data4, booktabs = TRUE, caption = "RMSE for Interpolation Methods along Border", col.names = c("Week", "X", "Y", "X", "Y"), escape = FALSE, table.attr = "style='width:80%;'") %>% 
  add_header_above(c("", "Joint Spatial" = 2, "Linear" = 2))


```

---
class:primary

#Interpolation Results for Week 1

```{r ice-results-tab2, message=FALSE, warning = FALSE}

result_data5 <- data.frame(Cluster = c(1,2,3,4,5,6), X1 = c(4.410,0.443,1.120,1.140,0.549, 1.320), Y1 = c(15.500, 0.870, 1.480, 1.980, 1.980, 2.970), X2 = c(1.330, 0.303, 1.770, 2.920, 0.969,2.330), Y2 = c(21.800, 0.527, 4.740, 3.420, 5.507, 7.450))

kableExtra::kable(result_data5, booktabs = TRUE, caption = "RMSE for Interpolation Methods by cluster for Week 1", col.names = c( "Cluster", "X", "Y", "X", "Y"), escape = FALSE, align = "c", table.attr = "style='width:80%;'") %>% add_header_above(c(" ", "Joint Spatial" = 2, "Linear" = 2)) %>% row_spec(c(1,3,4,5,6),color = 'black', background = 'yellow') 

```

---
class:primary

#Interpolation Results along Border by Week

+ Black Polygon (Cluster 4): Data is More Spread out and not linear
+ Red Polygon (Cluster 2): Data does not move much

.center[
```{r clust-help,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/inset-traj-plot.png", alt = "Overall trajectory plot with colored polygons to denote the location of the broken out clusters", other=list(width="80%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```

]

---
class:primary

#Coverage 

A benefit of using a model-based approach is that we can determine the uncertainty of our estimate.
  - Standard deviation of estimate computed using the posterior marginals, which are then used to create an interval of our estimates
  - The intervals can then be used to find the proportion of intervals containing the true amount of movement during testing of our models, otherwise known as coverage

<br>

```{r ice-results-tab3, message=FALSE, warning = FALSE}

result_data6 <- data.frame(Week = c(1,2,3), X1 = c(0.389, 0.451, 0.443), Y1 = c(0.37, 0.476, 0.373))

kableExtra::kable(result_data6, booktabs = TRUE, caption = "<b>Coverage</b>", col.names = c( "Week", "X", "Y"), escape = FALSE, align = "c", table.attr = "style='width:75%;'")
```


---
class:primary

# Discussion of Model


**Advantages**:

+ Takes into account the nonstationarity of the data
+ Showed some improvement, in terms of RMSE, over linear interpolation for curved data that is not highly sampled
+ Able to estimate data on first and last day of a dataset, which linear interpolation is not able to do. 
+ Able to calculate uncertainty
  
**Areas for Improvement**:

+ Computational efficiency
+ Coverage shows that there is room for improvement with the parameter estimations
+ Intersections

  
---
class:primary

#Future Work

+ Different method to determine number of clusters for lead detection.
  - For example, `r Citep(bib[[c("ossama_extended_2011")]])` has a process for determining the number of unique directions, which may be a better estimate of $k$. 
+ Methods to improve computational efficiency should be considered (parallel computing).
+ Currently, our interpolation method is a two-step process: find clusters and create model in each cluster. 
  - Eventually, we would like to turn this into a one-step process, potentially using Voronoi tessellations and a piecewise Gaussian Process. 
  - Combining everything into one step may also increase computational efficiency.

  

---
class:primary
# References

<font size="2">
```{r, print_refs1, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("alais-gestalt-1998", "andrienko_supporting_2000",
"andrienko_visual_2007",
"ansari_spatiotemporal_2020",
"badgley_1961",
"biesecker-2020",
"billen_nitrogen_2013",
"BLANGIARDO201333",
"BRAVO2004b",
"BRAVO2004a",
"brewer_2002"
)]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:primary
# References
<font size="2">
```{r, print_refs2, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("chalbi_gestalt",
"leaflet",
"cleveland_graphical_1984",
"gleicher2011",
"gordon_2015",
"griffin-maps-2006",
"climate-viz",
"he-mult-2019",
"huang2009"
)]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```


</font>

---
class:primary
# References

<font size="2">
```{r, print_refs3, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("key_detectability_1993",
"kisilevich_spatio-temporal_nodate",
"klippel-tobler-2011",
"kodinariya_2013",
"spde-book",
"Leonowicz2003RESEARCHOT",
"li-features",
"light-rainbow-2004",
"lyi2021",
"macdonald_1999"
)]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:primary
# References

<font size="2">
```{r, print_refs4, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("MAHESWARI2017175",
"maxwell-farm-2018",
"Miller1956TheMN",
"ossama_extended_2011",
"peterson_evaluating_2011",
"reiser_new_2020",
"rinzivillo_visuallydriven_2008",
"schreyer_elastic_2006",
"SILVA2011320",
"strode-2020"
)]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:primary
# References

<font size="2">
```{r, print_refs5, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("tilman_sustainalbe_2011",
"trevisan-spatial-2021",
"vanderplas2020",
"wagemans-2012-a",
"wagemans-2012-b",
"wang_comp18",
"wong2011color",
"wu-fish-2022",
"yuan_review_2017"

)]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:primary
#Acknowledgements


---
class:inverse
<br>
<br>
<br>
.center[
# Questions?
<br>
<br>

]
